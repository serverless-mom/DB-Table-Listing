const chai = require('chai');
const chaiAsPromised = require('chai-as-promised');

const { expect } = chai;
const sinon = require('sinon');
const proxyquire = require('proxyquire').noPreserveCache();
const tracer = require('../../src/tracer.js');
const eventInterface = require('../../src/event.js');
const consts = require('../../src/consts.js');
const awsLambdaTrigger = require('../../src/triggers/aws_lambda.js');
const lambdaWrapper = require('../../src/wrappers/lambda.js');
const errorCode = require('../../src/proto/error_code_pb.js');
const utils = require('../../src/utils.js');

chai.use(chaiAsPromised);

if (utils.isAsyncSupported) {
    describe('asyncLambdaWrapper tests', () => {
        beforeEach(() => {
            this.createFromEventStub = sinon.stub(
                awsLambdaTrigger,
                'createFromEvent'
            ).returns('trigger');

            this.restartStub = sinon.stub(
                tracer,
                'restart'
            );

            this.addEventStub = sinon.stub(
                tracer,
                'addEvent'
            );

            this.addExceptionStub = sinon.stub(
                tracer,
                'addException'
            );

            this.sendTraceStub = sinon.stub(
                tracer,
                'sendTrace'
            );

            this.sendTraceSyncStub = sinon.stub(
                tracer,
                'sendTraceSync'
            );

            this.setExceptionStub = sinon.stub(
                eventInterface,
                'setException'
            );

            this.stubFunction = sinon.stub();
            // hack so this file will be importable on platform without async
            // eslint-disable-next-line no-unused-vars
            const { stubFunction } = this;
            // eslint-disable-next-line no-eval
            this.asyncWrapper = eval('async (event, context, callback) => { return stubFunction(event, context, callback); };');
            this.wrappedStub = lambdaWrapper.lambdaWrapper(this.asyncWrapper);
            this.callbackStub = sinon.stub();
            consts.COLD_START = true;
        });

        afterEach(() => {
            this.createFromEventStub.restore();
            this.addEventStub.restore();
            this.addExceptionStub.restore();
            this.sendTraceStub.restore();
            this.sendTraceSyncStub.restore();
            this.restartStub.restore();
            this.setExceptionStub.restore();
        });

        it('asyncLambdaWrapper: return a function', () => {
            expect(this.wrappedStub).to.be.a('function');
        });

        it('asyncLambdaWrapper: sanity', () => expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(() => {
            expect(this.restartStub.callCount).to.equal(1);
            expect(this.createFromEventStub.callCount).to.equal(1);
            expect(this.createFromEventStub.calledWith({}));
            expect(this.addEventStub.callCount).to.equal(2);
            expect(this.addExceptionStub.called).to.be.false;
            expect(this.sendTraceStub.callCount).to.equal(1);
            expect(this.stubFunction.callCount).to.equal(1);
            expect(this.callbackStub.called).to.be.false;
            expect(this.setExceptionStub.called).to.be.false;
        }));

        it('asyncLambdaWrapper: create correct runner event', () => {
            const context = {
                functionName: 'functionName',
                awsRequestId: 'awsRequestId',
                logStreamName: 'logStreamName',
                logGroupName: 'logGroupName',
                functionVersion: 'functionVersion',
                memoryLimitInMB: 'memoryLimitInMB',
            };

            return expect(this.wrappedStub({}, context, this.callbackStub)).to.be.fulfilled.then(
                () => {
                    const runnerEvent = this.addEventStub.getCall(0).args[0];
                    expect(runnerEvent.getId()).to.equal('awsRequestId');
                    expect(runnerEvent.getStartTime()).to.be.ok;
                    // TODO: not validating duration cause it can be 0 or 0.01 (true/false)
                    expect(runnerEvent.getOrigin()).to.equal('runner');
                    expect(runnerEvent.getErrorCode()).to.equal(errorCode.ErrorCode.OK);
                    expect(runnerEvent.getException()).to.be.undefined;
                    const resource = runnerEvent.getResource();
                    expect(resource.getName()).to.equal('functionName');
                    expect(resource.getType()).to.equal('lambda');
                    expect(resource.getOperation()).to.equal('invoke');
                    expect(resource.getMetadataMap().get('log_stream_name')).to.equal('logStreamName');
                    expect(resource.getMetadataMap().get('log_group_name')).to.equal('logGroupName');
                    expect(resource.getMetadataMap().get('function_version')).to.equal('functionVersion');
                    expect(resource.getMetadataMap().get('cold_start')).to.equal('true');
                    expect(resource.getMetadataMap().get('memory')).to.equal('memoryLimitInMB');
                    expect(resource.getMetadataMap().get('region')).to.equal(consts.REGION);
                }
            );
        });

        it('asyncLambdaWrapper: trigger creation failure', () => {
            this.createFromEventStub.reset();
            this.createFromEventStub.throws();
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(() => {
                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(1);
                expect(this.addExceptionStub.callCount).to.equal(1);
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.called).to.be.false;
                expect(this.setExceptionStub.called).to.be.false;
            });
        });

        it('asyncLambdaWrapper: wrapped function throws error', () => {
            this.stubFunction.throws();
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.rejected.then(() => {
                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.called).to.be.false;
                expect(this.sendTraceSyncStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.called).to.be.false;
                expect(this.setExceptionStub.callCount).to.equal(1);
            });
        });

        it('asyncLambdaWrapper: wrapped callback success call', () => {
            this.stubFunction.callsArgWith(2, null, 'success');
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(() => {
                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.callCount).to.equal(1);
                expect(this.setExceptionStub.called).to.be.false;
            });
        });

        it('asyncLambdaWrapper: wrapped callback error call', () => {
            this.stubFunction.callsArgWith(2, Error());
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(() => {
                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.restartStub.callCount).to.equal(1);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.callCount).to.equal(1);
                expect(this.setExceptionStub.callCount).to.equal(1);
            });
        });

        it('asyncLambdaWrapper: update COLD_START value', () => {
            consts.COLD_START = true;
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(() => {
                expect(consts.COLD_START).to.be.false;
            });
        });

        it('asyncLambdaWrapper: COLD_START value should be false after more then 1 call', () => {
            consts.COLD_START = true;
            const promise1 = expect(
                this.wrappedStub({}, {}, this.callbackStub)
            ).to.be.fulfilled.then(() => {
                expect(consts.COLD_START).to.be.false;
            });

            const promise2 = expect(
                this.wrappedStub({}, {}, this.callbackStub)
            ).to.be.fulfilled.then(() => {
                expect(consts.COLD_START).to.be.false;
            });

            return Promise.all([promise1, promise2]);
        });

        it('asyncLambdaWrapper: null context', () => {
            this.stubFunction.returns('success');
            return expect(
                this.wrappedStub({}, null, this.callbackStub)
            ).to.be.fulfilled.then((result) => {
                expect(result).to.equal('success');
                expect(this.restartStub.callCount).to.equal(1);
                expect(this.createFromEventStub.callCount).to.equal(0);
                expect(this.addEventStub.callCount).to.equal(0);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(0);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.called).to.be.false;
                expect(this.setExceptionStub.called).to.be.false;
            });
        });
    });

    describe('asyncStepLambdaWrapper tests', () => {
        beforeEach(() => {
            this.createFromEventStub = sinon.stub(
                awsLambdaTrigger,
                'createFromEvent'
            ).returns('trigger');

            this.restartStub = sinon.stub(
                tracer,
                'restart'
            );

            this.addEventStub = sinon.stub(
                tracer,
                'addEvent'
            );

            this.addExceptionStub = sinon.stub(
                tracer,
                'addException'
            );

            this.sendTraceStub = sinon.stub(
                tracer,
                'sendTrace'
            );

            this.sendTraceSyncStub = sinon.stub(
                tracer,
                'sendTraceSync'
            );

            this.setExceptionStub = sinon.stub(
                eventInterface,
                'setException'
            );

            this.uuid4Stub = sinon.stub().returns(1);
            this.asyncLambdaWithPatchedDeps = proxyquire(
                '../../src/wrappers/async_lambda.js',
                {
                    uuid4: this.uuid4Stub,
                    '../tracer.js': tracer,
                    '../event.js': eventInterface,
                    '../triggers/aws_lambda.js': awsLambdaTrigger,
                }
            );
            this.lambdaWithPatchedDeps = proxyquire(
                '../../src/wrappers/lambda.js',
                {
                    '../wrappers/async_lambda.js': this.asyncLambdaWithPatchedDeps,
                }
            );

            this.stubFunction = sinon.stub().returns({ result: 1 });
            // hack so this file will be importable on platform without async
            // eslint-disable-next-line no-unused-vars
            const { stubFunction } = this;
            // eslint-disable-next-line no-eval
            this.asyncWrapper = eval('async (event, context, callback) => { return stubFunction(event, context, callback); };');
            this.wrappedStub = this.lambdaWithPatchedDeps.stepLambdaWrapper(this.asyncWrapper);
            this.callbackStub = sinon.stub();
            consts.COLD_START = true;
        });

        afterEach(() => {
            this.createFromEventStub.restore();
            this.addEventStub.restore();
            this.addExceptionStub.restore();
            this.sendTraceStub.restore();
            this.sendTraceSyncStub.restore();
            this.restartStub.restore();
            this.setExceptionStub.restore();
        });

        it('asyncStepLambdaWrapper: return a function', () => {
            expect(this.wrappedStub).to.be.a('function');
        });

        it('asyncStepLambdaWrapper: sanity first step', () => expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then((result) => {
            expect(result).to.contain.key('Epsagon');
            expect(result).to.contain.key('result');
            expect(this.restartStub.callCount).to.equal(1);
            expect(this.createFromEventStub.callCount).to.equal(1);
            expect(this.createFromEventStub.calledWith({}));
            expect(this.addEventStub.callCount).to.equal(2);
            expect(this.addExceptionStub.called).to.be.false;
            expect(this.sendTraceStub.callCount).to.equal(1);
            expect(this.stubFunction.callCount).to.equal(1);
            expect(this.callbackStub.called).to.be.false;
            expect(this.setExceptionStub.called).to.be.false;
            expect(this.uuid4Stub.calledOnce).to.be.true;
        }));

        it('asyncStepLambdaWrapper: sanity not first step', () => expect(this.wrappedStub(
            { Epsagon: { id: 1, step_num: 2 } },
            {},
            this.callbackStub
        )).to.be.fulfilled.then((result) => {
            expect(result).to.contain.key('Epsagon');
            expect(result.Epsagon.step_num).to.equal(3);
            expect(result).to.contain.key('result');
            expect(this.restartStub.callCount).to.equal(1);
            expect(this.createFromEventStub.callCount).to.equal(1);
            expect(this.createFromEventStub.calledWith({}));
            expect(this.addEventStub.callCount).to.equal(2);
            expect(this.addExceptionStub.called).to.be.false;
            expect(this.sendTraceStub.callCount).to.equal(1);
            expect(this.stubFunction.callCount).to.equal(1);
            expect(this.callbackStub.called).to.be.false;
            expect(this.setExceptionStub.called).to.be.false;
            expect(this.uuid4Stub.called).to.be.false;
        }));

        it('asyncStepLambdaWrapper: create correct runner event', () => {
            const context = {
                functionName: 'functionName',
                awsRequestId: 'awsRequestId',
                logStreamName: 'logStreamName',
                logGroupName: 'logGroupName',
                functionVersion: 'functionVersion',
                memoryLimitInMB: 'memoryLimitInMB',
            };

            return expect(
                this.wrappedStub({}, context, this.callbackStub)
            ).to.be.fulfilled.then(() => {
                const runnerEvent = this.addEventStub.getCall(0).args[0];
                expect(runnerEvent.getId()).to.equal('awsRequestId');
                expect(runnerEvent.getStartTime()).to.be.ok;
                // TODO: not validating duration cause it can be 0 or 0.01 (true/false)
                expect(runnerEvent.getOrigin()).to.equal('runner');
                expect(runnerEvent.getErrorCode()).to.equal(errorCode.ErrorCode.OK);
                expect(runnerEvent.getException()).to.be.undefined;
                const resource = runnerEvent.getResource();
                expect(resource.getName()).to.equal('functionName');
                expect(resource.getType()).to.equal('step_function_lambda');
                expect(resource.getOperation()).to.equal('invoke');
                expect(resource.getMetadataMap().get('log_stream_name')).to.equal('logStreamName');
                expect(resource.getMetadataMap().get('log_group_name')).to.equal('logGroupName');
                expect(resource.getMetadataMap().get('function_version')).to.equal('functionVersion');
                expect(resource.getMetadataMap().get('cold_start')).to.equal('true');
                expect(resource.getMetadataMap().get('memory')).to.equal('memoryLimitInMB');
                expect(resource.getMetadataMap().get('region')).to.equal(consts.REGION);
            });
        });

        it('asyncStepLambdaWrapper: wrapped function dont return object', () => {
            this.stubFunction.returns(3);
            return expect(
                this.wrappedStub({}, {}, this.callbackStub)
            ).to.be.fulfilled.then((result) => {
                // we are not handling this case yet, return value should be unchanged
                expect(result).to.not.contain.key('Epsagon');
                expect(result).to.equal(3);
                expect(this.restartStub.callCount).to.equal(1);
                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.called).to.be.false;
                expect(this.setExceptionStub.called).to.be.false;
                expect(this.uuid4Stub.called).to.be.false;
            });
        });

        it('asyncStepLambdaWrapper: trigger creation failure', () => {
            this.createFromEventStub.reset();
            this.createFromEventStub.throws();
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(
                () => {
                    expect(this.createFromEventStub.callCount).to.equal(1);
                    expect(this.createFromEventStub.calledWith({}));
                    expect(this.addEventStub.callCount).to.equal(1);
                    expect(this.addExceptionStub.callCount).to.equal(1);
                    expect(this.sendTraceStub.callCount).to.equal(1);
                    expect(this.stubFunction.callCount).to.equal(1);
                    expect(this.callbackStub.called).to.be.false;
                    expect(this.setExceptionStub.called).to.be.false;
                    expect(this.uuid4Stub.calledOnce).to.be.true;
                }
            );
        });

        it('asyncStepLambdaWrapper: wrapped function throws error', () => {
            this.stubFunction.throws();
            return expect(
                this.wrappedStub({}, {}, this.callbackStub)
            ).to.be.rejectedWith(Error).then(
                () => {
                    expect(this.createFromEventStub.callCount).to.equal(1);
                    expect(this.createFromEventStub.calledWith({}));
                    expect(this.addEventStub.callCount).to.equal(2);
                    expect(this.addExceptionStub.called).to.be.false;
                    expect(this.sendTraceStub.called).to.be.false;
                    expect(this.sendTraceSyncStub.callCount).to.equal(1);
                    expect(this.stubFunction.callCount).to.equal(1);
                    expect(this.callbackStub.called).to.be.false;
                    expect(this.setExceptionStub.callCount).to.equal(1);
                    expect(this.uuid4Stub.called).to.be.false;
                }
            );
        });

        it('asyncStepLambdaWrapper: wrapped callback success call', () => {
            this.stubFunction.callsArgWith(2, null, { result: 1 });
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(() => {
                expect(this.callbackStub.args[0][0]).to.be.null;
                expect(this.callbackStub.args[0][1]).to.nested.include({ 'Epsagon.step_num': 0 });

                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.callCount).to.equal(1);
                expect(this.setExceptionStub.called).to.be.false;
                expect(this.uuid4Stub.calledOnce).to.be.true;
            });
        });

        it('asyncStepLambdaWrapper: wrapped callback success call not first call', () => {
            this.stubFunction.callsArgWith(2, null, { result: 1 });
            return expect(this.wrappedStub(
                { Epsagon: { id: 1, step_num: 0 } },
                {},
                this.callbackStub
            )).to.be.fulfilled.then(() => {
                expect(this.callbackStub.args[0][0]).to.be.null;
                expect(this.callbackStub.args[0][1]).to.nested.include({ 'Epsagon.step_num': 1 });
                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.callbackStub.callCount).to.equal(1);
                expect(this.setExceptionStub.called).to.be.false;
                expect(this.uuid4Stub.called).to.be.false;
            });
        });

        it('asyncStepLambdaWrapper: wrapped callback success call and return value', () => {
            this.stubFunction.callsArgWith(2, null, { result: 1 });
            this.stubFunction.returns({ result: 1 });

            return expect(
                this.wrappedStub({}, {}, this.callbackStub)
            ).to.be.fulfilled.then((result) => {
                expect(this.callbackStub.args[0][0]).to.be.null;
                expect(this.callbackStub.args[0][1]).to.nested.include({ 'Epsagon.step_num': 0 });
                expect(result).to.nested.include({ 'Epsagon.step_num': 0 });

                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.callCount).to.equal(1);
                expect(this.setExceptionStub.called).to.be.false;
                expect(this.uuid4Stub.calledOnce).to.be.true;
            });
        });

        it('asyncStepLambdaWrapper: wrapped callback success call not first call and RV', () => {
            this.stubFunction.callsArgWith(2, null, { result: 1 });
            this.stubFunction.returns({ result: 1 });
            return expect(
                this.wrappedStub({ Epsagon: { id: 1, step_num: 0 } }, {}, this.callbackStub)
            ).to.be.fulfilled.then((result) => {
                expect(this.callbackStub.args[0][0]).to.be.null;
                expect(this.callbackStub.args[0][1]).to.nested.include({ 'Epsagon.step_num': 1 });
                expect(result).to.nested.include({ 'Epsagon.step_num': 1 });

                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.callCount).to.equal(1);
                expect(this.setExceptionStub.called).to.be.false;
                expect(this.uuid4Stub.called).to.be.false;
            });
        });

        it('asyncStepLambdaWrapper: wrapped callback error call', () => {
            this.stubFunction.callsArgWith(2, Error());
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(() => {
                expect(this.callbackStub.args[0][1]).to.be.undefined;
                expect(this.callbackStub.args[0][0]).to.not.have.nested.property('Epsagon.step_num');

                expect(this.createFromEventStub.callCount).to.equal(1);
                expect(this.createFromEventStub.calledWith({}));
                expect(this.addEventStub.callCount).to.equal(2);
                expect(this.addExceptionStub.called).to.be.false;
                expect(this.sendTraceStub.callCount).to.equal(1);
                expect(this.stubFunction.callCount).to.equal(1);
                expect(this.callbackStub.callCount).to.equal(1);
                expect(this.setExceptionStub.callCount).to.equal(1);
                expect(this.uuid4Stub.called).to.be.true;
            });
        });

        it('asyncStepLambdaWrapper: update COLD_START value', () => {
            consts.COLD_START = true;
            return expect(this.wrappedStub({}, {}, this.callbackStub)).to.be.fulfilled.then(() => {
                expect(consts.COLD_START).to.be.false;
            });
        });

        it('asyncStepLambdaWrapper: COLD_START value should be false after more then 1 call', () => {
            consts.COLD_START = true;

            const p1 = expect(
                this.wrappedStub({}, {}, this.callbackStub)
            ).to.be.fulfilled.then(() => {
                expect(consts.COLD_START).to.be.false;
            });

            const p2 = expect(
                this.wrappedStub({}, {}, this.callbackStub)
            ).to.be.fulfilled.then(() => {
                expect(consts.COLD_START).to.be.false;
            });

            return Promise.all([p1, p2]);
        });

        it('asyncStepLambdaWrapper: null context', () => expect(this.wrappedStub({}, null, this.callbackStub)).to.be.fulfilled.then(() => {
            expect(this.restartStub.callCount).to.equal(1);
            expect(this.createFromEventStub.callCount).to.equal(0);
            expect(this.addEventStub.callCount).to.equal(0);
            expect(this.addExceptionStub.called).to.be.false;
            expect(this.sendTraceStub.callCount).to.equal(0);
            expect(this.stubFunction.callCount).to.equal(1);
            expect(this.callbackStub.called).to.be.false;
            expect(this.setExceptionStub.called).to.be.false;
        }));
    });
}
